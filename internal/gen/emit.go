package gen

import (
	"iter"
	"os"
	"path/filepath"

	"github.com/akishichinibu/goenum/internal/model"
	"github.com/akishichinibu/goenum/internal/render"
	j "github.com/dave/jennifer/jen"
)

type fileManager map[string]*j.File

func (m fileManager) LoadOrCreate(path string, builder func(path string) *j.File) *j.File {
	file, ok := m[path]
	if ok {
		return file
	}

	file = builder(path)
	m[path] = file

	return file
}

func emitImpl(files fileManager, req *model.GenRequest) error {
	p := req.Unit.InternalImplFilePath()

	implFile := files.LoadOrCreate(p, func(path string) *j.File {
		f := j.NewFilePathName(path, req.Unit.GenPackageName())
		f.Commentf("Package %s provides implementation for a type-safe enum definition base on %s", req.Unit.GenPackageName(), req.Unit.ImportPath)
		f.Commentf("Code generated by goenum %s. DO NOT EDIT.", version)
		f.Line()

		return f
	})

	r, err := render.NewEnum(req, req.Enum)
	if err != nil {
		return err
	}

	if err := r.Render(fileEmitter(implFile)); err != nil {
		return err
	}

	return nil
}

func emitExport(files fileManager, req *model.GenRequest) error {
	p := req.Unit.ExportFilePath()

	exportFile := files.LoadOrCreate(p, func(path string) *j.File {
		f := j.NewFilePathName(path, req.Unit.PackageName())
		f.Commentf("This file provides the exported interface from %s", req.Unit.GenPackageName())
		f.Commentf("Code generated by goenum %s. DO NOT EDIT.", version)
		f.Line()

		return f
	})

	r, err := render.NewEnumExportRenderer(req, req.Enum)
	if err != nil {
		return err
	}

	if err := r.Render(fileEmitter(exportFile)); err != nil {
		return err
	}

	return nil
}

func emitEnum(requests iter.Seq2[*model.GenRequest, error]) error {
	files := make(map[string]*j.File)

	for req, err := range requests {
		if err != nil {
			return err
		}

		if err := emitImpl(files, req); err != nil {
			return err
		}

		if err := emitExport(files, req); err != nil {
			return err
		}
	}

	for path, file := range files {
		if err := safeSave(file, path); err != nil {
			return err
		}
	}

	return nil
}

func fileEmitter(f *j.File) render.Emitter {
	return func(ss ...*j.Statement) {
		for _, s := range ss {
			f.Add(s)
		}
	}
}

func safeSave(f *j.File, path string) error {
	if err := os.MkdirAll(filepath.Dir(path), os.ModePerm); err != nil {
		return err
	}

	if err := f.Save(path); err != nil {
		return err
	}

	return nil
}
